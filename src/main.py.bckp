import time
import random
import asyncio
import logging
import threading
import traceback
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, BotCommand
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.strategy import FSMStrategy

from src.handlers import router as main_router 
from src.handlers.helpers import notify_error
from src.middlewares.services import ServicesMiddleware
from src.services.order_manager import OrderManager
from src.services.scrapers import NewSiteScraper

from config import get_settings

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

dp = Dispatcher()

entry_queue = asyncio.Queue()

# Global posting control
posting_enabled = True


class BotApplication:

    def __init__(self):
        self.settings = get_settings()
        self.bot = Bot(
            token=self.settings.BOT_TOKEN,
            default=DefaultBotProperties(parse_mode=ParseMode.HTML),
        )
        self.dispatcher = None
        self.services = None
        self.entry_scraper = NewSiteScraper()
        self.order_manager = OrderManager(db_path="data/orders.db", max_orders=1000)
        self.services_middleware = ServicesMiddleware(self.order_manager)



    async def register_commands(self, bot: Bot) -> None:
        commands_list = [
            BotCommand(command="startpost", description="üöÄ Resume posting loads to the channel"),
            BotCommand(command="stoppost", description="‚è∏ Pause posting loads"),
            BotCommand(command="status", description="üìä Check whether posting is enabled"),
            BotCommand(command="clearorders", description="üßπ Clear all stored order IDs"),
            BotCommand(command="addcity", description="‚ûï Add a city to the filter list"),
            BotCommand(command="removecity", description="‚ûñ Remove a city from the filter list"),
            BotCommand(command="listcities", description="üìç Show all tracked cities"),
            BotCommand(command="help", description="‚ùì Show this help message"),
        ]
        await bot.set_my_commands(commands_list)

    async def setup_dispatcher(self):
        dp = Dispatcher(
            storage=MemoryStorage(),
            fsm_strategy=FSMStrategy.CHAT,
            events_isolation=None,
        )
                
        dp.message.middleware(self.services_middleware)
        dp.callback_query.middleware(self.services_middleware)

        dp.include_router(main_router)


    async def send_telegram_message(self, entry, max_retries=5, base_delay=2):
        logger = logging.getLogger(__name__)
        try:
            state_code = entry.get('state_code', '')
            message = (
                f"<b>New Load Bid:</b> <code>{entry['order_id']}</code>\n\n"
                f"<b>Distance:</b> {entry['distance']}\n\n"
                f"<b>Pickup:</b> {entry['pickup_time']}\n"
                f"<b>Delivery:</b> {entry['delivery_time']}\n\n"
                f"üöõ<b>Stops:</b>\n" + "\n".join(f"  <b>Stop {i+1}</b>: {stop}" for i, stop in enumerate(entry['stops'])) + "\n\n"
                f"#{state_code}\n\n"
                f"<a href='https://t.me/ben_usps'>USPS LOADS</a>"
            )
        except Exception as e:
            error_msg = f"Error formatting message: {str(e)}\n\nEntry data: {entry}"
            logger.error(error_msg, exc_info=True)
            if self.settings.ERROR_NOTIFICATION_ENABLED:
                await notify_error(error_msg, self.bot)
            return False

        attempt = 0
        while attempt < max_retries:
            try:
                await self.bot.send_message(
                    chat_id=self.settings.TELEGAM_CHANNEL_ID, text=message, 
                    parse_mode=ParseMode.HTML, 
                    disable_web_page_preview=True, 
                    reply_markup=InlineKeyboardMarkup(
                        inline_keyboard=[
                            [InlineKeyboardButton(text="üìç Map", url=entry['route'])]
                        ]
                    )
                )

                return True
            except Exception as e:
                delay = base_delay * (2 ** attempt) + random.uniform(0, 1)
                await asyncio.sleep(delay)
                attempt += 1
        return False

    async def process_entries(self):
        while True:
            try:
                entry = await entry_queue.get()
                
                if not posting_enabled:
                    logger.info(f"Posting disabled, skipping entry ID {entry['order_id']}")
                    entry_queue.task_done()
                    await asyncio.sleep(1)
                    continue
                
                success = await self.send_telegram_message(entry)
                if success:
                    logger.info(f"Successfully processed and marked as seen entry ID {entry['order_id']}")
                else:
                    logger.warning(f"Failed to send message for entry ID {entry['order_id']} - not marking as seen")
                entry_queue.task_done()
                await asyncio.sleep(3)
            except asyncio.CancelledError:
                logger.info("Process entries task cancelled")
                raise
            except Exception as e:
                error_msg = f"Error processing entry: {str(e)}\n\n{traceback.format_exc()}"
                logger.error(error_msg)
                if self.settings.ERROR_NOTIFICATION_ENABLED:
                    await notify_error(error_msg, self.bot)
                await asyncio.sleep(3)

    async def scraper_worker(self):
        while True:
            try:
                new_entries = self.entry_scraper.get_new_entries()
                unseen_entries = self.order_manager.process_new_entries(new_entries)
                
                for entry in unseen_entries:
                    try:
                        future = asyncio.run_coroutine_threadsafe(entry_queue.put(entry), main_loop)
                        future.result()
                    except Exception as queue_error:
                        logger.error(f"Failed to queue entry {entry.get('order_id', 'Unknown')}: {str(queue_error)}\n{traceback.format_exc()}")
                time.sleep(30)
            except Exception as e:
                error_msg = f"Error in scraper_worker: {str(e)}\n\n{traceback.format_exc()}"
                logger.error(error_msg)
                if self.settings.ERROR_NOTIFICATION_ENABLED:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(notify_error(error_msg, bot))
                    loop.close()
                time.sleep(60)

async def main():
    try:
        # Start the processing tasks
        process_task = asyncio.create_task(process_entries())
        threading.Thread(target=scraper_worker, daemon=True).start()
        
        # Start the bot polling for commands
        await dp.start_polling(bot)
        
    except (KeyboardInterrupt, SystemExit):
        process_task.cancel()
        try:
            await process_task
        except asyncio.CancelledError:
            raise
    except Exception as e:
        error_msg = f"Fatal error in main: {str(e)}\n\n{traceback.format_exc()}"
        logger.critical(error_msg)
        if settings.ERROR_NOTIFICATION_ENABLED:
            await notify_error(error_msg, bot)
        raise
    finally:
        await bot.session.close()

if __name__ == "__main__":
    main_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(main_loop)
    try:
        main_loop.run_until_complete(main())
    finally:
        main_loop.run_until_complete(main_loop.shutdown_asyncgens())
        main_loop.close()